/**
 * HTTP Client Tests
 * Tests for the HTTP utility client with timeout, error handling, and request methods
 */

import { HttpClient, ApiHttpError, httpClient } from '../../utils/http';
import { createMockResponse } from '../../setupTests';

describe('HttpClient', () => {
  let client: HttpClient;\n\n  beforeEach(() => {\n    client = new HttpClient('http://localhost:8000', 5000);\n  });\n\n  describe('GET requests', () => {\n    test('should make successful GET request', async () => {\n      const mockData = { message: 'Success' };\n      const mockFetch = global.fetch as jest.MockedFunction<typeof fetch>;\n      mockFetch.mockResolvedValue(await createMockResponse(mockData));\n\n      const result = await client.get('/test');\n      \n      expect(result).toEqual(mockData);\n      expect(fetch).toHaveBeenCalledWith(\n        'http://localhost:8000/test',\n        expect.objectContaining({\n          method: 'GET',\n          headers: { 'Content-Type': 'application/json' },\n        })\n      );\n    });\n\n    test('should add query parameters to GET request', async () => {\n      const mockData = { results: [] };\n      const mockFetch = global.fetch as jest.MockedFunction<typeof fetch>;\n      mockFetch.mockResolvedValue(await createMockResponse(mockData));\n\n      await client.get('/search', { q: 'test', limit: 10, active: true });\n      \n      expect(fetch).toHaveBeenCalledWith(\n        'http://localhost:8000/search?q=test&limit=10&active=true',\n        expect.objectContaining({ method: 'GET' })\n      );\n    });\n\n    test('should handle GET request without parameters', async () => {\n      const mockData = { status: 'ok' };\n      const mockFetch = global.fetch as jest.MockedFunction<typeof fetch>;\n      mockFetch.mockResolvedValue(await createMockResponse(mockData));\n\n      const result = await client.get('/status');\n      \n      expect(result).toEqual(mockData);\n      expect(fetch).toHaveBeenCalledWith(\n        'http://localhost:8000/status',\n        expect.objectContaining({ method: 'GET' })\n      );\n    });\n  });\n\n  describe('POST requests', () => {\n    test('should make successful POST request with data', async () => {\n      const requestData = { name: 'test', value: 123 };\n      const responseData = { id: 'created-123', ...requestData };\n      \n      const mockFetch = global.fetch as jest.MockedFunction<typeof fetch>;\n      mockFetch.mockResolvedValue(await createMockResponse(responseData));\n\n      const result = await client.post('/create', requestData);\n      \n      expect(result).toEqual(responseData);\n      expect(fetch).toHaveBeenCalledWith(\n        'http://localhost:8000/create',\n        expect.objectContaining({\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify(requestData),\n        })\n      );\n    });\n\n    test('should make POST request without data', async () => {\n      const responseData = { success: true };\n      \n      const mockFetch = global.fetch as jest.MockedFunction<typeof fetch>;\n      mockFetch.mockResolvedValue(await createMockResponse(responseData));\n\n      const result = await client.post('/trigger');\n      \n      expect(result).toEqual(responseData);\n      expect(fetch).toHaveBeenCalledWith(\n        'http://localhost:8000/trigger',\n        expect.objectContaining({\n          method: 'POST',\n          body: undefined,\n        })\n      );\n    });\n  });\n\n  describe('DELETE requests', () => {\n    test('should make successful DELETE request', async () => {\n      const responseData = { deleted: true };\n      \n      const mockFetch = global.fetch as jest.MockedFunction<typeof fetch>;\n      mockFetch.mockResolvedValue(await createMockResponse(responseData));\n\n      const result = await client.delete('/item/123');\n      \n      expect(result).toEqual(responseData);\n      expect(fetch).toHaveBeenCalledWith(\n        'http://localhost:8000/item/123',\n        expect.objectContaining({ method: 'DELETE' })\n      );\n    });\n\n    test('should add query parameters to DELETE request', async () => {\n      const responseData = { deleted: true };\n      \n      const mockFetch = global.fetch as jest.MockedFunction<typeof fetch>;\n      mockFetch.mockResolvedValue(await createMockResponse(responseData));\n\n      await client.delete('/items', { force: true, user_id: 'test-123' });\n      \n      expect(fetch).toHaveBeenCalledWith(\n        'http://localhost:8000/items?force=true&user_id=test-123',\n        expect.objectContaining({ method: 'DELETE' })\n      );\n    });\n  });\n\n  describe('Error handling', () => {\n    test('should throw ApiHttpError for HTTP errors', async () => {\n      const mockFetch = global.fetch as jest.MockedFunction<typeof fetch>;\n      mockFetch.mockResolvedValue({\n        ok: false,\n        status: 404,\n        statusText: 'Not Found',\n        headers: new Headers({ 'Content-Type': 'application/json' }),\n        json: () => Promise.resolve({ detail: 'Resource not found' }),\n      } as Response);\n\n      await expect(client.get('/missing')).rejects.toThrow('Resource not found');\n      await expect(client.get('/missing')).rejects.toBeInstanceOf(ApiHttpError);\n      \n      try {\n        await client.get('/missing');\n      } catch (error) {\n        expect(error).toBeInstanceOf(ApiHttpError);\n        if (error instanceof ApiHttpError) {\n          expect(error.status).toBe(404);\n          expect(error.statusText).toBe('Not Found');\n        }\n      }\n    });\n\n    test('should handle errors without detail field', async () => {\n      const mockFetch = global.fetch as jest.MockedFunction<typeof fetch>;\n      mockFetch.mockResolvedValue({\n        ok: false,\n        status: 500,\n        statusText: 'Internal Server Error',\n        headers: new Headers({ 'Content-Type': 'application/json' }),\n        json: () => Promise.resolve({ message: 'Something went wrong' }),\n      } as Response);\n\n      await expect(client.get('/error')).rejects.toThrow('Something went wrong');\n    });\n\n    test('should handle JSON parsing errors in error responses', async () => {\n      const mockFetch = global.fetch as jest.MockedFunction<typeof fetch>;\n      mockFetch.mockResolvedValue({\n        ok: false,\n        status: 400,\n        statusText: 'Bad Request',\n        headers: new Headers({ 'Content-Type': 'application/json' }),\n        json: () => Promise.reject(new Error('Invalid JSON')),\n      } as Response);\n\n      await expect(client.get('/bad-json')).rejects.toThrow('HTTP 400: Bad Request');\n    });\n\n    test('should handle non-JSON responses', async () => {\n      const mockFetch = global.fetch as jest.MockedFunction<typeof fetch>;\n      mockFetch.mockResolvedValue({\n        ok: true,\n        status: 200,\n        statusText: 'OK',\n        headers: new Headers({ 'Content-Type': 'text/plain' }),\n        text: () => Promise.resolve('Plain text response'),\n      } as Response);\n\n      const result = await client.get('/text');\n      expect(result).toBe('Plain text response');\n    });\n  });\n\n  describe('Timeout handling', () => {\n    test('should handle request timeout', async () => {\n      const mockFetch = global.fetch as jest.MockedFunction<typeof fetch>;\n      const timeoutError = new Error('Request timeout');\n      timeoutError.name = 'AbortError';\n      mockFetch.mockRejectedValue(timeoutError);\n\n      await expect(client.get('/slow')).rejects.toThrow('Request timeout');\n      await expect(client.get('/slow')).rejects.toBeInstanceOf(ApiHttpError);\n      \n      try {\n        await client.get('/slow');\n      } catch (error) {\n        expect(error).toBeInstanceOf(ApiHttpError);\n        if (error instanceof ApiHttpError) {\n          expect(error.status).toBe(408);\n          expect(error.statusText).toBe('Request Timeout');\n        }\n      }\n    });\n\n    test('should pass abort signal to fetch', async () => {\n      const mockFetch = global.fetch as jest.MockedFunction<typeof fetch>;\n      mockFetch.mockResolvedValue(await createMockResponse({ success: true }));\n\n      await client.get('/test');\n      \n      expect(fetch).toHaveBeenCalledWith(\n        expect.any(String),\n        expect.objectContaining({\n          signal: expect.any(AbortSignal),\n        })\n      );\n    });\n  });\n\n  describe('Base URL handling', () => {\n    test('should remove trailing slash from base URL', () => {\n      const clientWithSlash = new HttpClient('http://localhost:8000/', 5000);\n      const mockFetch = global.fetch as jest.MockedFunction<typeof fetch>;\n      mockFetch.mockResolvedValue(createMockResponse({ data: 'test' }));\n\n      clientWithSlash.get('/path');\n      \n      expect(fetch).toHaveBeenCalledWith(\n        'http://localhost:8000/path',\n        expect.any(Object)\n      );\n    });\n\n    test('should use default configuration', () => {\n      expect(httpClient).toBeInstanceOf(HttpClient);\n    });\n  });\n\n  describe('Health check', () => {\n    test('should perform health check', async () => {\n      const healthResponse = { status: 'healthy', message: 'All systems operational' };\n      const mockFetch = global.fetch as jest.MockedFunction<typeof fetch>;\n      mockFetch.mockResolvedValue(await createMockResponse(healthResponse));\n\n      const result = await client.healthCheck();\n      \n      expect(result).toEqual(healthResponse);\n      expect(fetch).toHaveBeenCalledWith(\n        'http://localhost:8000/health',\n        expect.objectContaining({ method: 'GET' })\n      );\n    });\n  });\n\n  describe('Headers and content type', () => {\n    test('should set correct default headers', async () => {\n      const mockFetch = global.fetch as jest.MockedFunction<typeof fetch>;\n      mockFetch.mockResolvedValue(await createMockResponse({}));\n\n      await client.get('/test');\n      \n      expect(fetch).toHaveBeenCalledWith(\n        expect.any(String),\n        expect.objectContaining({\n          headers: {\n            'Content-Type': 'application/json',\n          },\n        })\n      );\n    });\n\n    test('should allow header overrides', async () => {\n      // Note: This would require extending the HttpClient to support custom headers\n      // For now, we test that default headers are applied correctly\n      const mockFetch = global.fetch as jest.MockedFunction<typeof fetch>;\n      mockFetch.mockResolvedValue(await createMockResponse({}));\n\n      await client.post('/test', { data: 'test' });\n      \n      expect(fetch).toHaveBeenCalledWith(\n        expect.any(String),\n        expect.objectContaining({\n          headers: expect.objectContaining({\n            'Content-Type': 'application/json',\n          }),\n        })\n      );\n    });\n  });\n});\n\ndescribe('Environment configuration helpers', () => {\n  test('should get default user ID from environment', () => {\n    const { getDefaultUserId } = require('../../utils/http');\n    \n    expect(getDefaultUserId()).toBe('test-user-123');\n  });\n\n  test('should export API configuration constants', () => {\n    const { API_BASE_URL, API_TIMEOUT } = require('../../utils/http');\n    \n    expect(API_BASE_URL).toBe('http://localhost:8000');\n    expect(API_TIMEOUT).toBe(30000);\n  });\n});